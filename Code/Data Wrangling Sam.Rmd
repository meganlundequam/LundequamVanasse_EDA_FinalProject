---
title: "Data Wrangling"
author: "Megan Lundequam, Same Vanasse and Casey Slaught"
date: "3/30/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(plyr)
library(sf)
library(tidycensus)
library(tidyr)
library(tidyverse)
options(tigris_use_cache = TRUE)
library(scales)
library(sf)
library(dplyr)
library(lubridate)

theme_set(theme_classic())
```

```{r}
## Census Data
generatorsCensus2020 = st_read("../Data/Processed/generatorsCensus2020.geojson")
generatorsCensusNoGeometry = st_drop_geometry(generatorsCensus2020)

class(generatorsCensus2020)
class(generatorsCensusNoGeometry)

```


```{r}
## Generator Info
census.data <- read.csv("../Data/Processed/generatorsCensusCategoriesComplete.csv", stringsAsFactors = TRUE)

## Getting nameplate capacity
generator.data <- read.csv("../Data/2020EnergyData/3_1_Generator_Y2020.csv", stringsAsFactors = TRUE)

generator.data.agg <- 
  generator.data %>%
  subset(generator.data$State == "NC") %>%
  subset(select = c(County, Plant.Code, Prime.Mover, Nameplate.Capacity..MW.))

gen.data.2020 <- cbind(census.data, generator.data.agg$Nameplate.Capacity..MW.) %>% 
  rename(c("Nameplate.Capacity" = `generator.data.agg$Nameplate.Capacity..MW.`)) %>% 
  mutate(Nameplate.Capacity1 = as.numeric(as.character(Nameplate.Capacity)))

```


```{r}
## Aggregating Data
aggregated.gen.data <- 
  gen.data.2020 %>%
  group_by(County, Renewable.v.FossilFuel) %>%
  dplyr::summarise(energy.gen = sum(Nameplate.Capacity1))

processed.gen.census <- 
  full_join(aggregated.gen.data, census.data) %>%
  subset(select=c(County, Renewable.v.FossilFuel, energy.gen, MedianHouseholdIncome)) %>%
  distinct(.keep_all = TRUE)

total.gen.census <- 
  processed.gen.census %>%
  group_by(County) %>%
  dplyr::summarise(total.gen = sum(energy.gen))

final.gen.census <-
  full_join(processed.gen.census, total.gen.census)

renewable.county <- 
  final.gen.census %>%
  subset(Renewable.v.FossilFuel=='Renewable Fuel') 

fossil.county <- 
  final.gen.census %>%
  subset(Renewable.v.FossilFuel=='Fossil Fuel') 
```

```{r}
## Regression Analysis
energy.reg <- lm(data = final.gen.census, total.gen ~ MedianHouseholdIncome)
summary(energy.reg)

#energy.reg2 <- lm(data = final.gen.census, log(total.gen) ~ MedianHouseholdIncome)
#summary(energy.reg2)

energy.reg3 <- lm(data = final.gen.census, log(total.gen) ~ log(MedianHouseholdIncome))
summary(energy.reg3)

energy.reg4 <- lm(data = final.gen.census, total.gen ~ log(MedianHouseholdIncome))
summary(energy.reg4)

fossil.reg <- lm(data = fossil.county, log(energy.gen) ~ log(MedianHouseholdIncome))
summary(fossil.reg)

renewable.reg <- lm(data = renewable.county, log(energy.gen) ~ log(MedianHouseholdIncome))
summary(renewable.reg)

#renewable.reg <- lm(data = renewable.county, log(MedianHouseholdIncome) ~ energy.gen)
#summary(renewable.reg)


# Correlation
cor.test(final.gen.census$total.gen, final.gen.census$MedianHouseholdIncome)

plot(renewable.reg)

```


*****************
```{r, fig.height = 3, fig.width = 4}
par(mfrow = c(2,2), mar=c(4,4,4,4))
plot(irradiance.regression)
par(mfrow = c(1,1))
```

The option best suited for communicating findings is to plot the explanatory and response variables as a scatterplot. 

```{r, fig.height = 3, fig.width = 4}
# Plot the regression
irradiancebydepth <- 
  ggplot(PeterPaul.chem.nutrients, aes(x = depth, y = irradianceWater)) +
  ylim(0, 2000) +
  geom_point() 
print(irradiancebydepth) 
```

Given the distribution of irradiance values, we don't have a linear relationship between x and y in this case. Let's try log-transforming the irradiance values. Note we also removing the observations that seems to ba an outlier.

```{r, fig.height = 3, fig.width = 4}
PeterPaul.chem.nutrients <- filter(PeterPaul.chem.nutrients, 
                                   irradianceWater != 0 & irradianceWater < 5000)
irradiance.regression2 <- lm(data = PeterPaul.chem.nutrients, log(irradianceWater) ~ depth)
summary(irradiance.regression2)

par(mfrow = c(2,2), mar=c(4,4,4,4))
plot(irradiance.regression2)
par(mfrow = c(1,1))

# Add a line and standard error for the linear regression
irradiancebydepth2 <- 
  ggplot(PeterPaul.chem.nutrients, aes(x = depth, y = irradianceWater)) +
  geom_smooth(method = "lm") +
  scale_y_log10() +
  geom_point() 
print(irradiancebydepth2) 

# SE - confidence interval around smooth can also be removed
irradiancebydepth2 <- 
    ggplot(PeterPaul.chem.nutrients, aes(x = depth, y = irradianceWater)) +
    geom_point() +
    scale_y_log10() +  #log transformed values for irradianceWater
    geom_smooth(method = 'lm', se = FALSE, color = "black")
print(irradiancebydepth2)

# Make the graph attractive

```

## Multiple Linear Regression
It is possible, and often useful, to consider multiple continuous explanatory variables at a time in a linear regression. For example, total phosphorus concentration in Paul Lake (the unfertilized lake) could be dependent on depth and dissolved oxygen concentration: 

``` {r, fig.height = 3, fig.width = 4}
TPregression <- lm(data = subset(PeterPaul.chem.nutrients, lakename == "Paul Lake"), 
                   tp_ug ~ depth + dissolvedOxygen)
summary(TPregression)

TPplot <- ggplot(subset(PeterPaul.chem.nutrients, lakename == "Paul Lake"), 
                 aes(x = dissolvedOxygen, y = tp_ug, color = depth)) +
  geom_point() +
  xlim(0, 20)
print(TPplot)

par(mfrow = c(2,2), mar=c(4,4,4,4))
plot(TPregression)
par(mfrow = c(1,1))

```

## Correlation Plots
We can also make exploratory plots of several continuous data points to determine possible relationships, as well as covariance among explanatory variables. 

```{r, fig.height = 3, fig.width = 4}
#install.packages("corrplot")
library(corrplot)
PeterPaulnutrients <- 
  PeterPaul.chem.nutrients %>%
  select(tn_ug:po4) %>%
  na.omit()
PeterPaulCorr <- cor(PeterPaulnutrients)
corrplot(PeterPaulCorr, method = "ellipse")
corrplot.mixed(PeterPaulCorr, upper = "ellipse")
```

## AIC to select variables

However, it is possible to over-parameterize a linear model. Adding additional explanatory variables takes away degrees of freedom, and if explanatory variables co-vary the interpretation can become overly complicated. Remember, an ideal statistical model balances simplicity and explanatory power! To help with this tradeoff, we can use the **Akaike's Information Criterion (AIC)** to compute a stepwise regression that either adds explanatory variables from the bottom up or removes explanatory variables from a full set of suggested options. The smaller the AIC value, the better. 

Let's say we want to know which explanatory variables will allow us to best predict total phosphorus concentrations. Potential explanatory variables from the dataset could include depth, dissolved oxygen, temperature, PAR, total N concentration, and phosphate concentration.

```{r}
Paul.naomit <- PeterPaul.chem.nutrients %>%
  filter(lakename == "Paul Lake") %>%
  na.omit()

TPAIC <- lm(data = Paul.naomit, tp_ug ~ depth + dissolvedOxygen + 
              temperature_C + tn_ug + po4)

#Choose a model by AIC in a Stepwise Algorithm
step(TPAIC)
TPmodel <- lm(data = Paul.naomit, tp_ug ~ dissolvedOxygen + temperature_C + tn_ug)
summary(TPmodel)

```




