---
title: "Data Wrangling"
author: "Megan Lundequam, Same Vanasse and Casey Slaught"
date: "3/30/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(plyr)
library(sf)
library(tidycensus)
library(tidyr)
library(tidyverse)
options(tigris_use_cache = TRUE)
library(scales)
library(sf)
library(dplyr)
library(lubridate)
library(corrplot)


theme_set(theme_classic())
```

```{r}
## Census Data
allCensusVariables = load_variables(2020, "acs5", cache=TRUE)
#View(allCensusVariables)

##Names are not descriptive, but did not want to manipulate code too much so I simply applied new code numbers to the old names and will reclassify them later.

#'Mobility' ~ B07012_002 ~ Below 100 percent of the poverty level --GEOGRAPHICAL MOBILITY IN THE PAST YEAR BY POVERTY STATUS IN THE PAST 12 MONTHS FOR                                   CURRENT RESIDENCE IN THE UNITED STATES
#'Mobility2' ~ B07004B_001 GEOGRAPHICAL MOBILITY IN THE PAST YEAR (BLACK OR AFRICAN AMERICAN ALONE) FOR CURRENT RESIDENCE IN THE UNITED STATES
#'RaceAllocation' ~ B07404A_001 GEOGRAPHICAL MOBILITY IN THE PAST YEAR (WHITE ALONE) FOR RESIDENCE 1 YEAR AGO IN THE UNITED STATES
#'DetailedRace' ~ B23006_016 Some college or associate's degree --EDUCATIONAL ATTAINMENT BY EMPLOYMENT STATUS FOR THE POPULATION 25 TO 64 YEARS




UpdatedCensus = st_read("../Data/Processed/NC_county_complete3.geojson")
UpdatedCensusNoGeometry = st_drop_geometry(UpdatedCensus)

write.csv(UpdatedCensusNoGeometry, row.names = FALSE, 
          file = "../Data/Processed/UpdatedCensus.csv")
```


```{r}
## Adding new census info and cleaning it
additional.census <- read.csv("../Data/Processed/UpdatedCensus.csv", stringsAsFactors = TRUE) 
additional.census <- 
  additional.census %>%
  subset(select=c(County, TotalPopulation, NoSchooling, Mobility, RaceAllocation, DetailedRace)) %>%
  rename(c("PovertyMobility" = Mobility, "WhitePopMobility" = RaceAllocation, "CollegeDeg" = DetailedRace)) %>%
  mutate(Per.PovertyMobility = (PovertyMobility/TotalPopulation),
         MinorityMobility = (TotalPopulation - WhitePopMobility),
         Per.MinorityMobility = (MinorityMobility/TotalPopulation),
         Per.NoSchooling = (NoSchooling/TotalPopulation),
         Per.CollegeDeg = (CollegeDeg/TotalPopulation)
         )

## Generator Info
census.data <- read.csv("../Data/Processed/generatorsCensusCategoriesComplete.csv", stringsAsFactors = TRUE)
census.data <- 
  full_join(census.data, additional.census) %>%
  drop_na(Energy.Source.1)

## Getting nameplate capacity
generator.data <- read.csv("../Data/2020EnergyData/3_1_Generator_Y2020.csv", stringsAsFactors = TRUE)

## Selecting variables of interest
generator.data <- 
  generator.data %>%
  subset(generator.data$State == "NC") %>%
  subset(select = c(County, Plant.Code, Prime.Mover, Nameplate.Capacity..MW.))

## Adding income to the full generator data by county
full.data <- cbind(census.data, generator.data$Nameplate.Capacity..MW.) %>% 
  rename(c("Nameplate.Capacity" = `generator.data$Nameplate.Capacity..MW.`)) %>% 
  mutate(Nameplate.Capacity1 = as.numeric(as.character(Nameplate.Capacity)))

```


```{r}
## Aggregating the generator data so that it groups all of it by county and by generation type
aggregated.gen.data <- 
  full.data %>%
  group_by(County, Renewable.v.FossilFuel) %>%
  dplyr::summarise(energy.type.gen = sum(Nameplate.Capacity1))

## Joining it to the census data to have capacity and income in same file & selecting specific variables
processed.gen.census <- 
  full_join(aggregated.gen.data, census.data) %>%
  subset(select=c(County, Renewable.v.FossilFuel, energy.type.gen, MedianHouseholdIncome, TotalPopulation, Per.CollegeDeg, Per.PovertyMobility, Per.MinorityMobility, Per.NoSchooling)) %>%
  distinct(.keep_all = TRUE)

## Creating a total generation variable, Removing fossil vs renewable distinction
total.gen.census <- 
  processed.gen.census %>%
  group_by(County) %>%
  dplyr::summarise(total.gen = sum(energy.type.gen))

##Separating into 3 different data sets to analyse different impacts
Final.gen.census <-
  full_join(processed.gen.census, total.gen.census) 

Renewable.county <- 
  Final.gen.census %>%
  subset(Renewable.v.FossilFuel=='Renewable Fuel') 

Fossil.county <- 
  Final.gen.census %>%
  subset(Renewable.v.FossilFuel=='Fossil Fuel') 
```

```{r}
## Correlation Plot
Corr.data <- 
  Renewable.county %>%
  select(MedianHouseholdIncome:total.gen) %>%
  na.omit() %>%
  subset(select=-c(County))

cor.test(Corr.data$total.gen, Corr.data$MedianHouseholdIncome)
cor.test(Corr.data$total.gen, Corr.data$TotalPopulation)
cor.test(Corr.data$total.gen, Corr.data$Per.CollegeDeg)
cor.test(Corr.data$total.gen, Corr.data$Per.PovertyMobility)
cor.test(Corr.data$total.gen, Corr.data$Per.MinorityMobility)
cor.test(Corr.data$total.gen, Corr.data$Per.NoSchooling)
cor.test(Corr.data$total.gen, Corr.data$total.gen)

corrplot(Corr.data, method = "ellipse")
corrplot.mixed(Corr.data, upper = "ellipse")

## All variable Regression
regression.variables <- 
  lm(data = Final.gen.census, log(total.gen) ~ log(MedianHouseholdIncome) + 
       Per.CollegeDeg + Per.PovertyMobility + 
       Per.MinorityMobility)

## AIC
step(regression.variables)

## Regression Analysis
total.energy.reg <- 
  lm(data = Final.gen.census, log(total.gen) ~ log(MedianHouseholdIncome) + 
       Per.CollegeDeg + Per.PovertyMobility + 
       Per.MinorityMobility)
summary(total.energy.reg)


fossil.reg <- 
  lm(data = Fossil.county, log(energy.type.gen) ~ log(MedianHouseholdIncome) + 
       Per.CollegeDeg + Per.PovertyMobility + 
       Per.MinorityMobility)
summary(fossil.reg)

renewable.reg <- 
  lm(data = Renewable.county, log(energy.type.gen) ~ log(MedianHouseholdIncome) + 
       Per.CollegeDeg + Per.PovertyMobility + 
       Per.MinorityMobility)
summary(renewable.reg)


plot(renewable.reg)
plot(total.energy.reg)
plot(fossil.reg)


```


*****************
```{r, fig.height = 3, fig.width = 4}
par(mfrow = c(2,2), mar=c(4,4,4,4))
plot(irradiance.regression)
par(mfrow = c(1,1))
```

The option best suited for communicating findings is to plot the explanatory and response variables as a scatterplot. 

```{r, fig.height = 3, fig.width = 4}
# Plot the regression
irradiancebydepth <- 
  ggplot(PeterPaul.chem.nutrients, aes(x = depth, y = irradianceWater)) +
  ylim(0, 2000) +
  geom_point() 
print(irradiancebydepth) 
```

Given the distribution of irradiance values, we don't have a linear relationship between x and y in this case. Let's try log-transforming the irradiance values. Note we also removing the observations that seems to ba an outlier.

```{r, fig.height = 3, fig.width = 4}
PeterPaul.chem.nutrients <- filter(PeterPaul.chem.nutrients, 
                                   irradianceWater != 0 & irradianceWater < 5000)
irradiance.regression2 <- lm(data = PeterPaul.chem.nutrients, log(irradianceWater) ~ depth)
summary(irradiance.regression2)

par(mfrow = c(2,2), mar=c(4,4,4,4))
plot(irradiance.regression2)
par(mfrow = c(1,1))

# Add a line and standard error for the linear regression
irradiancebydepth2 <- 
  ggplot(PeterPaul.chem.nutrients, aes(x = depth, y = irradianceWater)) +
  geom_smooth(method = "lm") +
  scale_y_log10() +
  geom_point() 
print(irradiancebydepth2) 

# SE - confidence interval around smooth can also be removed
irradiancebydepth2 <- 
    ggplot(PeterPaul.chem.nutrients, aes(x = depth, y = irradianceWater)) +
    geom_point() +
    scale_y_log10() +  #log transformed values for irradianceWater
    geom_smooth(method = 'lm', se = FALSE, color = "black")
print(irradiancebydepth2)

# Make the graph attractive

```

## Multiple Linear Regression
It is possible, and often useful, to consider multiple continuous explanatory variables at a time in a linear regression. For example, total phosphorus concentration in Paul Lake (the unfertilized lake) could be dependent on depth and dissolved oxygen concentration: 

``` {r, fig.height = 3, fig.width = 4}
TPregression <- lm(data = subset(PeterPaul.chem.nutrients, lakename == "Paul Lake"), 
                   tp_ug ~ depth + dissolvedOxygen)
summary(TPregression)

TPplot <- ggplot(subset(PeterPaul.chem.nutrients, lakename == "Paul Lake"), 
                 aes(x = dissolvedOxygen, y = tp_ug, color = depth)) +
  geom_point() +
  xlim(0, 20)
print(TPplot)

par(mfrow = c(2,2), mar=c(4,4,4,4))
plot(TPregression)
par(mfrow = c(1,1))

```

## Correlation Plots
We can also make exploratory plots of several continuous data points to determine possible relationships, as well as covariance among explanatory variables. 

```{r, fig.height = 3, fig.width = 4}
#install.packages("corrplot")
library(corrplot)
PeterPaulnutrients <- 
  PeterPaul.chem.nutrients %>%
  select(tn_ug:po4) %>%
  na.omit()
PeterPaulCorr <- cor(PeterPaulnutrients)
corrplot(PeterPaulCorr, method = "ellipse")
corrplot.mixed(PeterPaulCorr, upper = "ellipse")
```

## AIC to select variables

However, it is possible to over-parameterize a linear model. Adding additional explanatory variables takes away degrees of freedom, and if explanatory variables co-vary the interpretation can become overly complicated. Remember, an ideal statistical model balances simplicity and explanatory power! To help with this tradeoff, we can use the **Akaike's Information Criterion (AIC)** to compute a stepwise regression that either adds explanatory variables from the bottom up or removes explanatory variables from a full set of suggested options. The smaller the AIC value, the better. 

Let's say we want to know which explanatory variables will allow us to best predict total phosphorus concentrations. Potential explanatory variables from the dataset could include depth, dissolved oxygen, temperature, PAR, total N concentration, and phosphate concentration.

```{r}
Paul.naomit <- PeterPaul.chem.nutrients %>%
  filter(lakename == "Paul Lake") %>%
  na.omit()

TPAIC <- lm(data = Paul.naomit, tp_ug ~ depth + dissolvedOxygen + 
              temperature_C + tn_ug + po4)

#Choose a model by AIC in a Stepwise Algorithm
step(TPAIC)
TPmodel <- lm(data = Paul.naomit, tp_ug ~ dissolvedOxygen + temperature_C + tn_ug)
summary(TPmodel)

```




